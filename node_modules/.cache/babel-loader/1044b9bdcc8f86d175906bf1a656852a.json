{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigurableModuleBuilder = void 0;\n\nconst logger_service_1 = require(\"../services/logger.service\");\n\nconst random_string_generator_util_1 = require(\"../utils/random-string-generator.util\");\n\nconst constants_1 = require(\"./constants\");\n\nconst utils_1 = require(\"./utils\");\n/**\n * Factory that lets you create configurable modules and\n * provides a way to reduce the majority of dynamic module boilerplate.\n *\n * @publicApi\n */\n\n\nclass ConfigurableModuleBuilder {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let parentBuilder = arguments.length > 1 ? arguments[1] : undefined;\n    this.options = options;\n    this.logger = new logger_service_1.Logger(ConfigurableModuleBuilder.name);\n\n    if (parentBuilder) {\n      this.staticMethodKey = parentBuilder.staticMethodKey;\n      this.factoryClassMethodKey = parentBuilder.factoryClassMethodKey;\n      this.transformModuleDefinition = parentBuilder.transformModuleDefinition;\n      this.extras = parentBuilder.extras;\n    }\n  }\n  /**\n   * Registers the \"extras\" object (a set of extra options that can be used to modify the dynamic module definition).\n   * Values you specify within the \"extras\" object will be used as default values (that can be overriden by module consumers).\n   *\n   * This method also applies the so-called \"module definition transform function\" that takes the auto-generated\n   * dynamic module object (\"DynamicModule\") and the actual consumer \"extras\" object as input parameters.\n   * The \"extras\" object consists of values explicitly specified by module consumers and default values.\n   *\n   * @example\n   * ```typescript\n   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>\n   *    ({ ...definition, global: extras.isGlobal })\n   * )\n   * ```\n   */\n\n\n  setExtras(extras) {\n    let transformDefinition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : def => def;\n    const builder = new ConfigurableModuleBuilder(this.options, this);\n    builder.extras = extras;\n    builder.transformModuleDefinition = transformDefinition;\n    return builder;\n  }\n  /**\n   * Dynamic modules must expose public static methods that let you pass in\n   * configuration parameters (control the module's behavior from the outside).\n   * Some frequently used names that you may have seen in other modules are:\n   * \"forRoot\", \"forFeature\", \"register\", \"configure\".\n   *\n   * This method \"setClassMethodName\" lets you specify the name of the\n   * method that will be auto-generated.\n   *\n   * @param key name of the method\n   */\n\n\n  setClassMethodName(key) {\n    const builder = new ConfigurableModuleBuilder(this.options, this);\n    builder.staticMethodKey = key;\n    return builder;\n  }\n  /**\n   * Asynchronously configured modules (that rely on other modules, i.e. \"ConfigModule\")\n   * let you pass the configuration factory class that will be registered and instantiated as a provider.\n   * This provider then will be used to retrieve the module's configuration. To provide the configuration,\n   * the corresponding factory method must be implemented.\n   *\n   * This method (\"setFactoryMethodName\") lets you control what method name will have to be\n   * implemented by the config factory (default is \"create\").\n   *\n   * @param key name of the method\n   */\n\n\n  setFactoryMethodName(key) {\n    const builder = new ConfigurableModuleBuilder(this.options, this);\n    builder.factoryClassMethodKey = key;\n    return builder;\n  }\n  /**\n   * Returns an object consisting of multiple properties that lets you\n   * easily construct dynamic configurable modules. See \"ConfigurableModuleHost\" interface for more details.\n   */\n\n\n  build() {\n    var _a, _b, _c, _d;\n\n    var _e;\n\n    (_a = this.staticMethodKey) !== null && _a !== void 0 ? _a : this.staticMethodKey = constants_1.DEFAULT_METHOD_KEY;\n    (_b = this.factoryClassMethodKey) !== null && _b !== void 0 ? _b : this.factoryClassMethodKey = constants_1.DEFAULT_FACTORY_CLASS_METHOD_KEY;\n    (_c = (_e = this.options).optionsInjectionToken) !== null && _c !== void 0 ? _c : _e.optionsInjectionToken = this.options.moduleName ? this.constructInjectionTokenString() : (0, utils_1.generateOptionsInjectionToken)();\n    (_d = this.transformModuleDefinition) !== null && _d !== void 0 ? _d : this.transformModuleDefinition = definition => definition;\n    return {\n      ConfigurableModuleClass: this.createConfigurableModuleCls(),\n      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,\n      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),\n      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE')\n    };\n  }\n\n  constructInjectionTokenString() {\n    const moduleNameInSnakeCase = this.options.moduleName.trim().split(/(?=[A-Z])/).join('_').toUpperCase();\n    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;\n  }\n\n  createConfigurableModuleCls() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const asyncMethodKey = this.staticMethodKey + constants_1.ASYNC_METHOD_SUFFIX;\n\n    class InternalModuleClass {\n      static [self.staticMethodKey](options) {\n        const providers = [{\n          provide: self.options.optionsInjectionToken,\n          useValue: this.omitExtras(options, self.extras)\n        }];\n\n        if (self.options.alwaysTransient) {\n          providers.push({\n            provide: constants_1.CONFIGURABLE_MODULE_ID,\n            useValue: (0, random_string_generator_util_1.randomStringGenerator)()\n          });\n        }\n\n        return self.transformModuleDefinition({\n          module: this,\n          providers\n        }, Object.assign(Object.assign({}, self.extras), options));\n      }\n\n      static [asyncMethodKey](options) {\n        const providers = this.createAsyncProviders(options);\n\n        if (self.options.alwaysTransient) {\n          providers.push({\n            provide: constants_1.CONFIGURABLE_MODULE_ID,\n            useValue: (0, random_string_generator_util_1.randomStringGenerator)()\n          });\n        }\n\n        return self.transformModuleDefinition({\n          module: this,\n          imports: options.imports || [],\n          providers\n        }, Object.assign(Object.assign({}, self.extras), options));\n      }\n\n      static omitExtras(input, extras) {\n        if (!extras) {\n          return input;\n        }\n\n        const moduleOptions = {};\n        const extrasKeys = Object.keys(extras);\n        Object.keys(input).filter(key => !extrasKeys.includes(key)).forEach(key => {\n          moduleOptions[key] = input[key];\n        });\n        return moduleOptions;\n      }\n\n      static createAsyncProviders(options) {\n        if (options.useExisting || options.useFactory) {\n          if (options.inject && options.provideInjectionTokensFrom) {\n            return [this.createAsyncOptionsProvider(options), ...(0, utils_1.getInjectionProviders)(options.provideInjectionTokensFrom, options.inject)];\n          }\n\n          return [this.createAsyncOptionsProvider(options)];\n        }\n\n        return [this.createAsyncOptionsProvider(options), {\n          provide: options.useClass,\n          useClass: options.useClass\n        }];\n      }\n\n      static createAsyncOptionsProvider(options) {\n        if (options.useFactory) {\n          return {\n            provide: self.options.optionsInjectionToken,\n            useFactory: options.useFactory,\n            inject: options.inject || []\n          };\n        }\n\n        return {\n          provide: self.options.optionsInjectionToken,\n          useFactory: async optionsFactory => await optionsFactory[self.factoryClassMethodKey](),\n          inject: [options.useExisting || options.useClass]\n        };\n      }\n\n    }\n\n    return InternalModuleClass;\n  }\n\n  createTypeProxy(typeName) {\n    const proxy = new Proxy({}, {\n      get: () => {\n        throw new Error(`\"${typeName}\" is not supposed to be used as a value.`);\n      }\n    });\n    return proxy;\n  }\n\n}\n\nexports.ConfigurableModuleBuilder = ConfigurableModuleBuilder;","map":{"version":3,"names":["Object","defineProperty","exports","value","ConfigurableModuleBuilder","logger_service_1","require","random_string_generator_util_1","constants_1","utils_1","constructor","options","parentBuilder","logger","Logger","name","staticMethodKey","factoryClassMethodKey","transformModuleDefinition","extras","setExtras","transformDefinition","def","builder","setClassMethodName","key","setFactoryMethodName","build","_a","_b","_c","_d","_e","DEFAULT_METHOD_KEY","DEFAULT_FACTORY_CLASS_METHOD_KEY","optionsInjectionToken","moduleName","constructInjectionTokenString","generateOptionsInjectionToken","definition","ConfigurableModuleClass","createConfigurableModuleCls","MODULE_OPTIONS_TOKEN","ASYNC_OPTIONS_TYPE","createTypeProxy","OPTIONS_TYPE","moduleNameInSnakeCase","trim","split","join","toUpperCase","self","asyncMethodKey","ASYNC_METHOD_SUFFIX","InternalModuleClass","providers","provide","useValue","omitExtras","alwaysTransient","push","CONFIGURABLE_MODULE_ID","randomStringGenerator","module","assign","createAsyncProviders","imports","input","moduleOptions","extrasKeys","keys","filter","includes","forEach","useExisting","useFactory","inject","provideInjectionTokensFrom","createAsyncOptionsProvider","getInjectionProviders","useClass","optionsFactory","typeName","proxy","Proxy","get","Error"],"sources":["C:/Users/Admin/Desktop/NikeShoes/node_modules/@nestjs/common/module-utils/configurable-module.builder.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurableModuleBuilder = void 0;\nconst logger_service_1 = require(\"../services/logger.service\");\nconst random_string_generator_util_1 = require(\"../utils/random-string-generator.util\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\n/**\n * Factory that lets you create configurable modules and\n * provides a way to reduce the majority of dynamic module boilerplate.\n *\n * @publicApi\n */\nclass ConfigurableModuleBuilder {\n    constructor(options = {}, parentBuilder) {\n        this.options = options;\n        this.logger = new logger_service_1.Logger(ConfigurableModuleBuilder.name);\n        if (parentBuilder) {\n            this.staticMethodKey = parentBuilder.staticMethodKey;\n            this.factoryClassMethodKey =\n                parentBuilder.factoryClassMethodKey;\n            this.transformModuleDefinition = parentBuilder.transformModuleDefinition;\n            this.extras = parentBuilder.extras;\n        }\n    }\n    /**\n     * Registers the \"extras\" object (a set of extra options that can be used to modify the dynamic module definition).\n     * Values you specify within the \"extras\" object will be used as default values (that can be overriden by module consumers).\n     *\n     * This method also applies the so-called \"module definition transform function\" that takes the auto-generated\n     * dynamic module object (\"DynamicModule\") and the actual consumer \"extras\" object as input parameters.\n     * The \"extras\" object consists of values explicitly specified by module consumers and default values.\n     *\n     * @example\n     * ```typescript\n     * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>\n     *    ({ ...definition, global: extras.isGlobal })\n     * )\n     * ```\n     */\n    setExtras(extras, transformDefinition = def => def) {\n        const builder = new ConfigurableModuleBuilder(this.options, this);\n        builder.extras = extras;\n        builder.transformModuleDefinition = transformDefinition;\n        return builder;\n    }\n    /**\n     * Dynamic modules must expose public static methods that let you pass in\n     * configuration parameters (control the module's behavior from the outside).\n     * Some frequently used names that you may have seen in other modules are:\n     * \"forRoot\", \"forFeature\", \"register\", \"configure\".\n     *\n     * This method \"setClassMethodName\" lets you specify the name of the\n     * method that will be auto-generated.\n     *\n     * @param key name of the method\n     */\n    setClassMethodName(key) {\n        const builder = new ConfigurableModuleBuilder(this.options, this);\n        builder.staticMethodKey = key;\n        return builder;\n    }\n    /**\n     * Asynchronously configured modules (that rely on other modules, i.e. \"ConfigModule\")\n     * let you pass the configuration factory class that will be registered and instantiated as a provider.\n     * This provider then will be used to retrieve the module's configuration. To provide the configuration,\n     * the corresponding factory method must be implemented.\n     *\n     * This method (\"setFactoryMethodName\") lets you control what method name will have to be\n     * implemented by the config factory (default is \"create\").\n     *\n     * @param key name of the method\n     */\n    setFactoryMethodName(key) {\n        const builder = new ConfigurableModuleBuilder(this.options, this);\n        builder.factoryClassMethodKey = key;\n        return builder;\n    }\n    /**\n     * Returns an object consisting of multiple properties that lets you\n     * easily construct dynamic configurable modules. See \"ConfigurableModuleHost\" interface for more details.\n     */\n    build() {\n        var _a, _b, _c, _d;\n        var _e;\n        (_a = this.staticMethodKey) !== null && _a !== void 0 ? _a : (this.staticMethodKey = constants_1.DEFAULT_METHOD_KEY);\n        (_b = this.factoryClassMethodKey) !== null && _b !== void 0 ? _b : (this.factoryClassMethodKey = constants_1.DEFAULT_FACTORY_CLASS_METHOD_KEY);\n        (_c = (_e = this.options).optionsInjectionToken) !== null && _c !== void 0 ? _c : (_e.optionsInjectionToken = this.options.moduleName\n            ? this.constructInjectionTokenString()\n            : (0, utils_1.generateOptionsInjectionToken)());\n        (_d = this.transformModuleDefinition) !== null && _d !== void 0 ? _d : (this.transformModuleDefinition = definition => definition);\n        return {\n            ConfigurableModuleClass: this.createConfigurableModuleCls(),\n            MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,\n            ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),\n            OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),\n        };\n    }\n    constructInjectionTokenString() {\n        const moduleNameInSnakeCase = this.options.moduleName\n            .trim()\n            .split(/(?=[A-Z])/)\n            .join('_')\n            .toUpperCase();\n        return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;\n    }\n    createConfigurableModuleCls() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const asyncMethodKey = this.staticMethodKey + constants_1.ASYNC_METHOD_SUFFIX;\n        class InternalModuleClass {\n            static [self.staticMethodKey](options) {\n                const providers = [\n                    {\n                        provide: self.options.optionsInjectionToken,\n                        useValue: this.omitExtras(options, self.extras),\n                    },\n                ];\n                if (self.options.alwaysTransient) {\n                    providers.push({\n                        provide: constants_1.CONFIGURABLE_MODULE_ID,\n                        useValue: (0, random_string_generator_util_1.randomStringGenerator)(),\n                    });\n                }\n                return self.transformModuleDefinition({\n                    module: this,\n                    providers,\n                }, Object.assign(Object.assign({}, self.extras), options));\n            }\n            static [asyncMethodKey](options) {\n                const providers = this.createAsyncProviders(options);\n                if (self.options.alwaysTransient) {\n                    providers.push({\n                        provide: constants_1.CONFIGURABLE_MODULE_ID,\n                        useValue: (0, random_string_generator_util_1.randomStringGenerator)(),\n                    });\n                }\n                return self.transformModuleDefinition({\n                    module: this,\n                    imports: options.imports || [],\n                    providers,\n                }, Object.assign(Object.assign({}, self.extras), options));\n            }\n            static omitExtras(input, extras) {\n                if (!extras) {\n                    return input;\n                }\n                const moduleOptions = {};\n                const extrasKeys = Object.keys(extras);\n                Object.keys(input)\n                    .filter(key => !extrasKeys.includes(key))\n                    .forEach(key => {\n                    moduleOptions[key] = input[key];\n                });\n                return moduleOptions;\n            }\n            static createAsyncProviders(options) {\n                if (options.useExisting || options.useFactory) {\n                    if (options.inject && options.provideInjectionTokensFrom) {\n                        return [\n                            this.createAsyncOptionsProvider(options),\n                            ...(0, utils_1.getInjectionProviders)(options.provideInjectionTokensFrom, options.inject),\n                        ];\n                    }\n                    return [this.createAsyncOptionsProvider(options)];\n                }\n                return [\n                    this.createAsyncOptionsProvider(options),\n                    {\n                        provide: options.useClass,\n                        useClass: options.useClass,\n                    },\n                ];\n            }\n            static createAsyncOptionsProvider(options) {\n                if (options.useFactory) {\n                    return {\n                        provide: self.options.optionsInjectionToken,\n                        useFactory: options.useFactory,\n                        inject: options.inject || [],\n                    };\n                }\n                return {\n                    provide: self.options.optionsInjectionToken,\n                    useFactory: async (optionsFactory) => await optionsFactory[self.factoryClassMethodKey](),\n                    inject: [options.useExisting || options.useClass],\n                };\n            }\n        }\n        return InternalModuleClass;\n    }\n    createTypeProxy(typeName) {\n        const proxy = new Proxy({}, {\n            get: () => {\n                throw new Error(`\"${typeName}\" is not supposed to be used as a value.`);\n            },\n        });\n        return proxy;\n    }\n}\nexports.ConfigurableModuleBuilder = ConfigurableModuleBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}