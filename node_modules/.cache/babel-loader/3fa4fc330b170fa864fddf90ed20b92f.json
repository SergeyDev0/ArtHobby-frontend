{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParseFilePipe = void 0;\n\nconst tslib_1 = require(\"tslib\");\n\nconst shared_utils_1 = require(\"../../utils/shared.utils\");\n\nconst core_1 = require(\"../../decorators/core\");\n\nconst enums_1 = require(\"../../enums\");\n\nconst http_error_by_code_util_1 = require(\"../../utils/http-error-by-code.util\");\n/**\n * Defines the built-in ParseFile Pipe. This pipe can be used to validate incoming files\n * with `@UploadedFile()` decorator. You can use either other specific built-in validators\n * or provide one of your own, simply implementing it through {@link FileValidator}\n * interface and adding it to ParseFilePipe's constructor.\n *\n * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)\n *\n * @publicApi\n */\n\n\nlet ParseFilePipe = class ParseFilePipe {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      exceptionFactory,\n      errorHttpStatusCode = enums_1.HttpStatus.BAD_REQUEST,\n      validators = [],\n      fileIsRequired\n    } = options;\n\n    this.exceptionFactory = exceptionFactory || (error => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error));\n\n    this.validators = validators;\n    this.fileIsRequired = fileIsRequired !== null && fileIsRequired !== void 0 ? fileIsRequired : true;\n  }\n\n  async transform(value) {\n    if ((0, shared_utils_1.isUndefined)(value)) {\n      if (this.fileIsRequired) {\n        throw this.exceptionFactory('File is required');\n      }\n\n      return value;\n    }\n\n    if (this.validators.length) {\n      await this.validate(value);\n    }\n\n    return value;\n  }\n\n  async validate(file) {\n    for (const validator of this.validators) {\n      await this.validateOrThrow(file, validator);\n    }\n\n    return file;\n  }\n\n  async validateOrThrow(file, validator) {\n    const isValid = await validator.isValid(file);\n\n    if (!isValid) {\n      const errorMessage = validator.buildErrorMessage(file);\n      throw this.exceptionFactory(errorMessage);\n    }\n  }\n  /**\n   * @returns list of validators used in this pipe.\n   */\n\n\n  getValidators() {\n    return this.validators;\n  }\n\n};\nParseFilePipe = tslib_1.__decorate([(0, core_1.Injectable)(), tslib_1.__param(0, (0, core_1.Optional)()), tslib_1.__metadata(\"design:paramtypes\", [Object])], ParseFilePipe);\nexports.ParseFilePipe = ParseFilePipe;","map":{"version":3,"names":["Object","defineProperty","exports","value","ParseFilePipe","tslib_1","require","shared_utils_1","core_1","enums_1","http_error_by_code_util_1","constructor","options","exceptionFactory","errorHttpStatusCode","HttpStatus","BAD_REQUEST","validators","fileIsRequired","error","HttpErrorByCode","transform","isUndefined","length","validate","file","validator","validateOrThrow","isValid","errorMessage","buildErrorMessage","getValidators","__decorate","Injectable","__param","Optional","__metadata"],"sources":["C:/Users/Admin/Desktop/NikeShoes/node_modules/@nestjs/common/pipes/file/parse-file.pipe.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseFilePipe = void 0;\nconst tslib_1 = require(\"tslib\");\nconst shared_utils_1 = require(\"../../utils/shared.utils\");\nconst core_1 = require(\"../../decorators/core\");\nconst enums_1 = require(\"../../enums\");\nconst http_error_by_code_util_1 = require(\"../../utils/http-error-by-code.util\");\n/**\n * Defines the built-in ParseFile Pipe. This pipe can be used to validate incoming files\n * with `@UploadedFile()` decorator. You can use either other specific built-in validators\n * or provide one of your own, simply implementing it through {@link FileValidator}\n * interface and adding it to ParseFilePipe's constructor.\n *\n * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)\n *\n * @publicApi\n */\nlet ParseFilePipe = class ParseFilePipe {\n    constructor(options = {}) {\n        const { exceptionFactory, errorHttpStatusCode = enums_1.HttpStatus.BAD_REQUEST, validators = [], fileIsRequired, } = options;\n        this.exceptionFactory =\n            exceptionFactory ||\n                (error => new http_error_by_code_util_1.HttpErrorByCode[errorHttpStatusCode](error));\n        this.validators = validators;\n        this.fileIsRequired = fileIsRequired !== null && fileIsRequired !== void 0 ? fileIsRequired : true;\n    }\n    async transform(value) {\n        if ((0, shared_utils_1.isUndefined)(value)) {\n            if (this.fileIsRequired) {\n                throw this.exceptionFactory('File is required');\n            }\n            return value;\n        }\n        if (this.validators.length) {\n            await this.validate(value);\n        }\n        return value;\n    }\n    async validate(file) {\n        for (const validator of this.validators) {\n            await this.validateOrThrow(file, validator);\n        }\n        return file;\n    }\n    async validateOrThrow(file, validator) {\n        const isValid = await validator.isValid(file);\n        if (!isValid) {\n            const errorMessage = validator.buildErrorMessage(file);\n            throw this.exceptionFactory(errorMessage);\n        }\n    }\n    /**\n     * @returns list of validators used in this pipe.\n     */\n    getValidators() {\n        return this.validators;\n    }\n};\nParseFilePipe = tslib_1.__decorate([\n    (0, core_1.Injectable)(),\n    tslib_1.__param(0, (0, core_1.Optional)()),\n    tslib_1.__metadata(\"design:paramtypes\", [Object])\n], ParseFilePipe);\nexports.ParseFilePipe = ParseFilePipe;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,aAAR,GAAwB,KAAK,CAA7B;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAAvB;;AACA,MAAMC,cAAc,GAAGD,OAAO,CAAC,0BAAD,CAA9B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,aAAD,CAAvB;;AACA,MAAMI,yBAAyB,GAAGJ,OAAO,CAAC,qCAAD,CAAzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIF,aAAa,GAAG,MAAMA,aAAN,CAAoB;EACpCO,WAAW,GAAe;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IACtB,MAAM;MAAEC,gBAAF;MAAoBC,mBAAmB,GAAGL,OAAO,CAACM,UAAR,CAAmBC,WAA7D;MAA0EC,UAAU,GAAG,EAAvF;MAA2FC;IAA3F,IAA+GN,OAArH;;IACA,KAAKC,gBAAL,GACIA,gBAAgB,KACXM,KAAK,IAAI,IAAIT,yBAAyB,CAACU,eAA1B,CAA0CN,mBAA1C,CAAJ,CAAmEK,KAAnE,CADE,CADpB;;IAGA,KAAKF,UAAL,GAAkBA,UAAlB;IACA,KAAKC,cAAL,GAAsBA,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK,KAAK,CAAnD,GAAuDA,cAAvD,GAAwE,IAA9F;EACH;;EACc,MAATG,SAAS,CAAClB,KAAD,EAAQ;IACnB,IAAI,CAAC,GAAGI,cAAc,CAACe,WAAnB,EAAgCnB,KAAhC,CAAJ,EAA4C;MACxC,IAAI,KAAKe,cAAT,EAAyB;QACrB,MAAM,KAAKL,gBAAL,CAAsB,kBAAtB,CAAN;MACH;;MACD,OAAOV,KAAP;IACH;;IACD,IAAI,KAAKc,UAAL,CAAgBM,MAApB,EAA4B;MACxB,MAAM,KAAKC,QAAL,CAAcrB,KAAd,CAAN;IACH;;IACD,OAAOA,KAAP;EACH;;EACa,MAARqB,QAAQ,CAACC,IAAD,EAAO;IACjB,KAAK,MAAMC,SAAX,IAAwB,KAAKT,UAA7B,EAAyC;MACrC,MAAM,KAAKU,eAAL,CAAqBF,IAArB,EAA2BC,SAA3B,CAAN;IACH;;IACD,OAAOD,IAAP;EACH;;EACoB,MAAfE,eAAe,CAACF,IAAD,EAAOC,SAAP,EAAkB;IACnC,MAAME,OAAO,GAAG,MAAMF,SAAS,CAACE,OAAV,CAAkBH,IAAlB,CAAtB;;IACA,IAAI,CAACG,OAAL,EAAc;MACV,MAAMC,YAAY,GAAGH,SAAS,CAACI,iBAAV,CAA4BL,IAA5B,CAArB;MACA,MAAM,KAAKZ,gBAAL,CAAsBgB,YAAtB,CAAN;IACH;EACJ;EACD;AACJ;AACA;;;EACIE,aAAa,GAAG;IACZ,OAAO,KAAKd,UAAZ;EACH;;AAvCmC,CAAxC;AAyCAb,aAAa,GAAGC,OAAO,CAAC2B,UAAR,CAAmB,CAC/B,CAAC,GAAGxB,MAAM,CAACyB,UAAX,GAD+B,EAE/B5B,OAAO,CAAC6B,OAAR,CAAgB,CAAhB,EAAmB,CAAC,GAAG1B,MAAM,CAAC2B,QAAX,GAAnB,CAF+B,EAG/B9B,OAAO,CAAC+B,UAAR,CAAmB,mBAAnB,EAAwC,CAACpC,MAAD,CAAxC,CAH+B,CAAnB,EAIbI,aAJa,CAAhB;AAKAF,OAAO,CAACE,aAAR,GAAwBA,aAAxB"},"metadata":{},"sourceType":"script"}