{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInjectionProviders = void 0;\n/**\n * check if x is OptionalFactoryDependency, based on prototype presence\n * (to avoid classes with a static 'token' field)\n * @param x\n * @returns x is OptionalFactoryDependency\n */\n\nfunction isOptionalFactoryDependency(x) {\n  return !!((x === null || x === void 0 ? void 0 : x.token) && !(x === null || x === void 0 ? void 0 : x.prototype));\n}\n\nconst mapInjectToTokens = t => isOptionalFactoryDependency(t) ? t.token : t;\n/**\n *\n * @param providers List of a module's providers\n * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)\n * @returns All the providers needed for the tokens' injection (searched recursively)\n */\n\n\nfunction getInjectionProviders(providers, tokens) {\n  const result = [];\n  let search = tokens.map(mapInjectToTokens);\n\n  while (search.length > 0) {\n    const match = (providers !== null && providers !== void 0 ? providers : []).filter(p => !result.includes(p) && ( // this prevents circular loops and duplication\n    search.includes(p) || search.includes(p === null || p === void 0 ? void 0 : p.provide)));\n    result.push(...match); // get injection tokens of the matched providers, if any\n\n    search = match.filter(p => p === null || p === void 0 ? void 0 : p.inject).map(p => p.inject).flat().map(mapInjectToTokens);\n  }\n\n  return result;\n}\n\nexports.getInjectionProviders = getInjectionProviders;","map":{"version":3,"names":["Object","defineProperty","exports","value","getInjectionProviders","isOptionalFactoryDependency","x","token","prototype","mapInjectToTokens","t","providers","tokens","result","search","map","length","match","filter","p","includes","provide","push","inject","flat"],"sources":["C:/Users/Admin/Desktop/NikeShoes/node_modules/@nestjs/common/module-utils/utils/get-injection-providers.util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInjectionProviders = void 0;\n/**\n * check if x is OptionalFactoryDependency, based on prototype presence\n * (to avoid classes with a static 'token' field)\n * @param x\n * @returns x is OptionalFactoryDependency\n */\nfunction isOptionalFactoryDependency(x) {\n    return !!((x === null || x === void 0 ? void 0 : x.token) && !(x === null || x === void 0 ? void 0 : x.prototype));\n}\nconst mapInjectToTokens = (t) => isOptionalFactoryDependency(t) ? t.token : t;\n/**\n *\n * @param providers List of a module's providers\n * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)\n * @returns All the providers needed for the tokens' injection (searched recursively)\n */\nfunction getInjectionProviders(providers, tokens) {\n    const result = [];\n    let search = tokens.map(mapInjectToTokens);\n    while (search.length > 0) {\n        const match = (providers !== null && providers !== void 0 ? providers : []).filter(p => !result.includes(p) && // this prevents circular loops and duplication\n            (search.includes(p) || search.includes(p === null || p === void 0 ? void 0 : p.provide)));\n        result.push(...match);\n        // get injection tokens of the matched providers, if any\n        search = match\n            .filter(p => p === null || p === void 0 ? void 0 : p.inject)\n            .map(p => p.inject)\n            .flat()\n            .map(mapInjectToTokens);\n    }\n    return result;\n}\nexports.getInjectionProviders = getInjectionProviders;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgC,KAAK,CAArC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,2BAAT,CAAqCC,CAArC,EAAwC;EACpC,OAAO,CAAC,EAAE,CAACA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,KAAK,CAAzB,GAA6B,KAAK,CAAlC,GAAsCA,CAAC,CAACC,KAAzC,KAAmD,EAAED,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,KAAK,CAAzB,GAA6B,KAAK,CAAlC,GAAsCA,CAAC,CAACE,SAA1C,CAArD,CAAR;AACH;;AACD,MAAMC,iBAAiB,GAAIC,CAAD,IAAOL,2BAA2B,CAACK,CAAD,CAA3B,GAAiCA,CAAC,CAACH,KAAnC,GAA2CG,CAA5E;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASN,qBAAT,CAA+BO,SAA/B,EAA0CC,MAA1C,EAAkD;EAC9C,MAAMC,MAAM,GAAG,EAAf;EACA,IAAIC,MAAM,GAAGF,MAAM,CAACG,GAAP,CAAWN,iBAAX,CAAb;;EACA,OAAOK,MAAM,CAACE,MAAP,GAAgB,CAAvB,EAA0B;IACtB,MAAMC,KAAK,GAAG,CAACN,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6CA,SAA7C,GAAyD,EAA1D,EAA8DO,MAA9D,CAAqEC,CAAC,IAAI,CAACN,MAAM,CAACO,QAAP,CAAgBD,CAAhB,CAAD,MAAuB;IAC1GL,MAAM,CAACM,QAAP,CAAgBD,CAAhB,KAAsBL,MAAM,CAACM,QAAP,CAAgBD,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,KAAK,CAAzB,GAA6B,KAAK,CAAlC,GAAsCA,CAAC,CAACE,OAAxD,CAD6D,CAA1E,CAAd;IAEAR,MAAM,CAACS,IAAP,CAAY,GAAGL,KAAf,EAHsB,CAItB;;IACAH,MAAM,GAAGG,KAAK,CACTC,MADI,CACGC,CAAC,IAAIA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAK,KAAK,CAAzB,GAA6B,KAAK,CAAlC,GAAsCA,CAAC,CAACI,MADhD,EAEJR,GAFI,CAEAI,CAAC,IAAIA,CAAC,CAACI,MAFP,EAGJC,IAHI,GAIJT,GAJI,CAIAN,iBAJA,CAAT;EAKH;;EACD,OAAOI,MAAP;AACH;;AACDX,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC"},"metadata":{},"sourceType":"script"}